---
title: "やってみての感想とまとめ"
---

ここまで進めてきたところまでの学びをまとめます！
改めてコードベースのリポジトリを貼っておきます。

https://github.com/theMistletoe/postgres-prisma


# やってみた学び

## 1. テストカバレッジは高く維持できそう

今回の取組で一通りテストと実装を終えた後のテストカバレッジは以下の通りです。

![カバレッジレポート](/images/7d6ab272d3e8ab/coverage.png)

カバレッジレポートは下記に公開しています。
https://tdd-coverage-sample.netlify.app/

テストファーストで進めていくことにより、当たり前ですがテストカバレッジ自体は高く保つことが出来そうです。

## 2. Testing Trophyの考え方からフロントエンドの場合結合的なテストを厚くするべきだが、どうしてもカスタムフックや純粋コンポーネントなどの小さな単体テストが増えていく

react-testing-libraryの作者であるKent C. Doddsの提唱した考え方に「Testing Trophy」というものがあります。

https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications

この説明だけで大変なのですが、ものすごく要約すると**Integration Testをしっかり書くことがコストとリターンのバランスが取りやすく、ユーザーから見たふるまいをテストすることがよりフロントエンド・UIの信頼性を高めることに繋がる**という考え方です。

例えば、カスタムフックを利用するUI部品があったとします。(例えばTODOリストを表示するために、APIからTODOアイテムを取得するUI部品を想像しましょう。)

カスタムフックのテストだけを実施していた場合、仮にうまくTODOアイテムを取得できていることが確認出来ていたとしても、カスタムフックを利用する部品が使い方を間違えている(例えばTODOをタイトルを表示すべきところに、TODOの完了状態を表示していた)場合、ユーザーは想定通りの使い方が出来ないはずです。

極端な例を上げましたが、このようにフロントエンドの場合ロジックとViewが密接に関係していて、最終的なユーザーへの価値としては **「ユーザーが期待通りのふるまい・操作ができるかどうか」** という観点の信頼性を高めるほうが良さそうです。
そのため、 **カスタムフックを利用したUIコンポーネントを統合的にテストして、ユーザーのふるまいが想定通りになっているのかのテストをした方が、効率的・効果的にテスト出来そう** だと感じています。

今回のようにテストファーストで進める場合、

> a. カスタムフックのテスト
> b. カスタムフックの実装
> c. コンポーネントのテスト
> d. コンポーネントの実装

という流れで進めていきました。


このとき、aとcで似たようなテストを書く形にもなり、少し冗長にも感じました。


> (これはカスタムフックに限らず、コンポーネントの親子関係でも同様のことが発生しました。例えば親コンポーネントであるCalenderのコンポーネントに予定を表示しようとしたときに、子や孫のコンポーネントをやっぱり先にテストしないといけないことになり、結構同じようなテストを書くことになる冗長さを感じました。)

もちろん、テストされていないよりはされていたほうが良いので、「まぁこれでもええんか…」と思いましたが、冗長・過剰なテストにつながるケースもあるかと感じました。


## 3. HTMLのセマンティクスなところは直接的なユーザー挙動には影響なしとしてリファクタの範疇でやっていたが、それでいいのか

2.での方針に合わせて、今回のフロントエンドのテストでは「ユーザーのふるまい」にフォーカスしてテストする方針としていました。
私自身セマンティクスにあまり詳しくないこともあるのですが、使用するタグを変えても挙動に影響しなさそうな場合はリファクタリングの一環として修正してしまっていました。
このあたりは是非が問われる・方針を決める必要があるかと感じました。

## 4. 同じくCSSの修飾部分の調整等もリファクタリングで実施していたが、どうなのか

3.と少し似ていますが、CSSもどのタイミングで修正しようか迷いました。

今回取り組んだ感想は以下のとおりです。

- 今回のTDDはUIのふるまいテストするというスコープとした。
- visible性をコントロールするような対応の場合はユーザーのふるまいに影響するので、テストを書いてから修正する。
- カラーを変更したり、見た目を修正する場合は、ユーザーのふるまいに影響なさそう、としてリファクタリングの中で修正する。
- が、marginを変更したりすることにより画面から見えなくなったりすることもありそうなので、影響を事前に把握仕切ることは難しそう。
- 見た目に関するテストについては、別の観点としてスナップショットテストやVRTで担保するほうが良さそう。(このあたりはE2Eテスト等も含め、どういう観点をどのテストで担保するのかの設計が必要になるかと思います。)



## 5. 必然的にコンポーネント設計をせざるを得ないので、設計改善したい場合は有効かもしれない

実装前にUI部品・コンポーネント・カスタムフックなどをどのように利用するのかをある程度設計してから実装していく必要があるので、
その観点での設計改善効果は得られるかと感じました。
実際にコーディングしながら「おもてたんと違うな…」となれば、実装しながら調整していくこともできるので、その観点でもメリットはあるかもと感じました。




## 6. 実際に動かして描画してみないと、見た目の部分とか適切にテス・実装できているかが分かりづらい・できていない場面があった。

TDDで進めるとテストコードと実装を行き来して進めていくので、実際にブラウザ上でどうレンダリングされているかを確認することなく進めているシーンがありました。
(自分のコーディング力が低いのもありますが)表示されている状態を確認して初めてうまく描画されていないことに気がついたタイミングもありました。
UIの表示や描画は事前に想定しきれない部分もよくあるかと思いますので、TDDサイクルの中でもレンダリングされている様子を確認した方が良いかもしれません。

## 7. よりフロントエンドのアーキテクチャ・設計の複雑度が上がるとよりわけがわからなくなりそう。

今回は少し複雑なUIを順次実装していきましたが、それでも普段みなさんが実装されているのはもっと複雑なUIのアプリケーションを実装されていることと思います。
画面の複雑度もそうですし、普段の実装の際には技術的にも複雑度が高いと考えられます。
(例えばグローバルステートが絡むとか、インメモリキャッシュが絡むとか、SSRが絡むとか…)

それらが加わることで更に複雑性になって、よりテストの難易度やTDDの進め方が煩雑になる可能性もあるかと感じました。

# まとめ


今回はフロントエンドでTDDを取り組んでみた流れを追ってみました。
卑怯な言い方になりましたが、開発の中でTDDを採択するのかについては、チームの状態や実際にやってみた上での学びを加味しながら、自分たちで納得した形で取り組む必要があるかと思います。
実際に取り組んで見る際にもふりかえりを実施しつつ、「実際のところどうなの?」を自分たちで学び取りながら取り組んでいきましょう。

今回の学びがフロントエンドでのTDDの実践に少しでもヒントになれば幸いです！



---

:::message
まだ作成した実装のすべてを書き起こしたわけではありません。
「残りの部分も気になる！」と思われた方は、いいね&コメントくだされば続き書こうと思います。
:::
